/*
 * Copyright (c) 2024 Aventyr
 *
 * All rights reserved in Aventyr authored and generated code (including the selection and arrangement of the source code
 * base regardless of the authorship of individual files), but not including any copyright interest(s) owned by a third party
 * related to source code or object code authored or generated by non-Aventyr personnel.
 *
 * This source code includes Aventyr confidential and/or proprietary information and may include Aventyr trade secrets.
 * Any use, disclosure and/or reproduction is prohibited unless authorized in writing.
 *
 * Publication Rights :: Aventyr Private
 */

package postgres

import (
	"context"
	"fmt"

	sq "github.com/Masterminds/squirrel"
	"github.com/jackc/pgx/v5"
)

// SQLBuilder (like squirrel builders) implements ToSQL that
// returns the SQL statement to run against the database
type SQLBuilder interface {
	// ToSQL returns the SQL statement and arguments to run
	// The args are used to handle prepared statements. Therefore, they must be provided
	// in the order of the various placeholder for smooth substitution
	ToSQL() (stmt string, args []any, err error)
}

// squirrelAdapter transform a squirrel Sqlizer into a SQLBuilder
// that can be run in a transaction
type squirrelAdapter struct {
	s sq.Sqlizer
}

func (s squirrelAdapter) ToSQL() (string, []any, error) {
	return s.s.ToSql()
}

// TxRunner helps run SQL statements in a safe database transaction.
// In case of errors the underlying transaction is rolled back
// When there are no errors the underlying transaction is automatically committed
type TxRunner struct {
	tx       pgx.Tx
	builders []SQLBuilder
	ctx      context.Context
}

// NewTxRunner creates an instance of TxRunner
func NewTxRunner(ctx context.Context, db Postgres) (*TxRunner, error) {
	tx, err := db.BeginTx(ctx, pgx.TxOptions{IsoLevel: pgx.ReadCommitted})
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	return &TxRunner{
		tx:       tx,
		builders: nil,
		ctx:      ctx,
	}, nil
}

// AddSQLBuilder adds a SQL builder to the TxRunner
func (runner *TxRunner) AddSQLBuilder(builder SQLBuilder) *TxRunner {
	runner.builders = append(runner.builders, builder)
	return runner
}

// AddSQLBuilders an array of SQL builder to the TxRunner
func (runner *TxRunner) AddSQLBuilders(builders ...SQLBuilder) *TxRunner {
	runner.builders = append(runner.builders, builders...)
	return runner
}

// AddSqlizer adds a squirrel builder to the TxRunner
func (runner *TxRunner) AddSqlizer(s sq.Sqlizer) *TxRunner {
	runner.builders = append(runner.builders, squirrelAdapter{s: s})
	return runner
}

// Run executes the database transaction and returns the resulting error.
// In case of errors the underlying transaction is rolled back
// When there are no errors the underlying transaction is automatically committed
func (runner *TxRunner) Run() error {
	type stmt struct {
		query string
		args  []any
	}

	// build the SQL statements to execute with the database transaction
	// rollback the transaction when there is an error
	stmts := make([]stmt, 0, len(runner.builders))
	for _, builder := range runner.builders {
		q, args, err := builder.ToSQL()
		if err != nil {
			// rollback the transaction
			if rollbackErr := runner.tx.Rollback(runner.ctx); rollbackErr != nil {
				return fmt.Errorf("failed to rollback transaction: %w", rollbackErr)
			}
			return fmt.Errorf("failed to build query: %w", err)
		}

		stmts = append(stmts, stmt{
			query: q,
			args:  args,
		})
	}

	// execute the SQL statements build with the database transaction
	for _, stmt := range stmts {
		if _, err := runner.tx.Exec(runner.ctx, stmt.query, stmt.args...); err != nil {
			// rollback the transaction
			if rollbackErr := runner.tx.Rollback(runner.ctx); rollbackErr != nil {
				return fmt.Errorf("failed to rollback transaction: %w", rollbackErr)
			}
			return fmt.Errorf("failed to execute query: %w", err)
		}
	}

	return runner.tx.Commit(runner.ctx)
}
